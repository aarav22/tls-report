The TLS record protocol \cite{rfc8446} protects traffic between peers using parameters established by the handshake protocol. Each data packet is referred to as a record, containing a header and a payload. The header includes record type, protocol version, and payload length, while the payload contains the actual data being sent.

TLS defines a Record Layer to receive uninterpreted data from higher layers in non-empty blocks of arbitrary size \cite{rfc2246}. This layer fragments information blocks into \code{TLSPlaintext} records with data chunks of $2^{14}$ bytes or less. There are four record types: \code{ChangeCipherSpec}, \code{Alert}, \code{Handshake}, and \code{ApplicationData}.

The \code{ChangeCipherSpec} record, now deprecated, is used to change the cipher suite used for encryption. The \code{Alert} record is used to send error messages. The \code{Handshake} record is used to send handshake messages, while the \code{ApplicationData} record is used to send application data.

Delignat-Lavaud et al \cite{7958593} argue that each sub-protocol of TLS defines its own data stream, and the record layer is responsible for multiplexing all of these streams into one corresponding to network messages after fragmentation, formatting, padding, and optional record-layer encryption (application data is compulsorily encrypted). According to this model, the record layer is the exclusive user for all non-exported keys generated by the handshake. 

The record protection functions by translating a \code{TLSPlaintext} structure into a \code{TLSCiphertext} structure \cite{rfc8446}. \code{TLSCiphertext} (encrypted record) consists of a plaintext header followed by an encrypted body, which itself contains a type and optional padding.

As per new changes in TLS 1.3, the record layer protection is improved by adopting a single AEAD mode for all ciphersuites, thus deprecating all legacy modes (MAC-only, MAC-pad-encrypt, encrypt-then-MAC \cite{rfc7366}, compress-then-encrypt) \cite{7958593}. The new AEAD mode is designed to be provably-secure and modular, supporting algorithms such as AES-GCM, AES-CCM, and ChaCha20-Poly1305 within the same framework. Recall that AEAD algorithms take as input a single key, a nonce, a plaintext, and ``additional data'' to be included in the authentication check. The key is either of the traffic key generated in \ref{eq:traffic_keys}, the nonce is derived from the sequence number and the \code{client write iv ($iv_{capp}$)} or \code{server write iv ({$iv_{sapp}$)}}, and the additional data input is the record header.

The IVs are generated as follows: 
\begin{equation}
    \begin{split}
        iv_{capp} &= \code{HKDF-Expand-Label(CATS, "iv", "", iv\_length)}\\
        iv_{sapp} &= \code{HKDF-Expand-Label(SATS, "iv", "", iv\_length)}
    \end{split}
\end{equation}

\begin{verbatim}
    additional_data = TLSCiphertext.opaque_type ||
                        TLSCiphertext.legacy_record_version ||
                        TLSCiphertext.length
\end{verbatim}
Here, \code{opaque\_type} is always set to 23 for outward
compatibility with middleboxes accustomed to parsing previous
versions of TLS. The \code{legacy\_record\_version} field is always 0x0303. Finally, the \code{length} (in bytes) of the ecnrypted record. 

A 64-bit sequence number is maintained separately for reading and writing records \cite{rfc8446}. The appropriate sequence number is incremented by one after reading or writing each record. Each sequence number is set to zero at the beginning of a connection and whenever the key is changed; the first record transmitted under a particular traffic key must use sequence number 0. The padded sequence number is XORed with either the $iv_{capp}$ or $iv_{capp}$ (we may use handshake traffic ivs and keys in case of handshake messages). This resulting value is used as the per-record nonce for the AEAD algorithm.