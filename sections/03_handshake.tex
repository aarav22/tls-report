For consistency with the notation, we let P play the role of the client and Q play the role of the server. P and Q wish to setup a secure session. 

\textbf{TLS 1.3} supports both one-sided and mutual authentication. In most cases, authentication for the client is optional. In the notation, $(E_s , D_s)$ is a symmetric encryption scheme that provides authenticated encryption, such as AES-128 in GCM mode.  Algorithm $S$ refers to a MAC signing algorithm, such as HMAC-SHA256. Algorithms $Sig_P(\cdot )$ and $Sig_Q(\cdot )$ sign the provided data using P's or Q's signing keys. Finally, the hash functions $H_1, H_2$ are used to derive symmetric keys. They are built from HKDF with hash functions such as SHA-256. 

The cipher-suites which determine the symmetric encryption scheme, the hash function in the MAC signing algorithm and HKDF are negotiated during the handshake. The cipher-suites are defined in \cite{rfc8446}. They are specified in Table \ref{tab:ciphersuites}. TLS negotiates these algorithms, rather than hard code a specific choice, because some organizations may prefer to use different algorithms based on their policies.

\textbf{The protocol.} In the first step \textbf{Client Hello}, P sends a message to Q. The message contains a 32 bytes nonce $\mathcal{N}_c$ generated by a secure random number generator and an ``offer''. The offer specifies the group, a list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. In fact, the client can provide several groups in his offer using a ``supported\_groups'' extension though constrained to be one of several pre-defined groups, which include both elliptic curves and subgroups of finite fields. A ``key\_share'' extension provides corresponding group elements for each group. Clients which desire the server to authenticate itself via a certificate must send the ``signature\_algorithms'' extension which indicates the signature algorithms the client can accept. 

After receiving the first flow, the server Q examines the ``offer'' sent by the client. It verifies that the group (or groups) preferred by the client coincides with the group (or groups) that the server is able and willing to use. It also selects an encryption scheme $(E_s , D_s)$ and a hash function
from the offer that it is willing and able to use, if any. If the server is unable to find a compatible group and encryption/hash schemes, the server may send a special ``retry'' request to the client.

The server now responds with \textbf{Server Hello} containing its own nonce $\mathcal{N}_s$, a ``mode'' message which
indicates the parameter choices (group, encryption/hash scheme) made by the server along with the key share corresponding to the selected group. The server now has the ability to encrypt further messages since it posesses both the key shares to construct a \\ \textit{server\_handshake\_traffic\_secret} as follows \cite{rfc8446}:
% \begin{equation}
%   \label{eq:server_handshake_traffic_secret}
  \begin{verbatim}
  early_secret =  HKDF-Extract(0, 0)
  derived_secret = Derive-Secret(early_secret, "derived", "")
  handshake_secret =  HKDF-Extract(derived_secret, (EC)DHE shared secret)
  server_handshake_traffic_secret = Derive-Secret(, "s hs traffic", 
                                      ClientHello...ServerHello)
  \end{verbatim}
% \end{equation}

The server sends \textbf{EncryptedExtensions} message immediately after the ServerHello message for sending extensions that can be protected. This is followed by \textbf{Certificate Request} message, which is only sent if the server wishes to authenticate the client. If present, this message specifies the type of certificates the server will accept. Finally, the server sends \textbf{Authentication Messages} for authentication, key confirmation (provide explicit proof that an endpoint possesses the private key corresponding to its certificate), and handshake
integrity: \textbf{Certificate}, \textbf{CertificateVerify}, and \textbf{Finished}. 
\begin{itemize}
  \item Certificate: The server's certificate, and any supporting certificates in the chain.
  \item CertificateVerify: A signature over the value
 Transcript-Hash \footnote{Transcript-Hash is computed by hashing the concatenation of each included handshake message, including the handshake message header carrying the handshake message type and length fields, but not
 including record layer headers \cite{rfc8446}.}(Handshake Context, Certificate). Here, Handshake Context consists of ClientHello, ServerHello, EncryptedExtensions, and CertificateRequest (the conversation so far) using server's signing key. 
  \item Finished: This is the final message in the Authentication Messages. It is essential for providing authentication of the handshake and of the computed keys. Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive \textbf{Application Data} over the connection. The message contains a MAC over the value Transcript-Hash(Handshake Context,Certificate, CertificateVerify) using a MAC key derived from the server\_handshake\_traffic\_secret as:
  \begin{equation}
    \label{eq:finished}
    \begin{split}
      \text{server\_finished\_key =
      HKDF-Expand-Label(server\_handshake\_traffic\_secret,} \\ \text{ ``finished'', ``'', Hash.length)}
    \end{split}
  \end{equation}
\end{itemize}


\newpage
\begin{table}[t]
  \centering
  \begin{tabular}{|l|l|}
    \hline Description & Value \\
    \hline 
    TLS\_AES\_128\_GCM\_SHA256 & $\{0\times13,0\times01\}$ \\
    \hline TLS\_AES\_256\_GCM\_SHA384 & $\{0\times13,0\times02\}$ \\
    \hline TLS\_CHACHA20\_POLY1305\_SHA256 & $\{0\times13,0\times03\}$ \\
    \hline TLS\_AES\_128\_CCM\_SHA256 & $\{0\times13,0\times04\}$ \\
    \hline TLS\_AES\_128\_CCM\_8\_SHA256 & $\{0\times13,0\times05\}$ \\
    \hline
  \end{tabular}
  \caption{Cipher-Suites \cite{rfc8446}. Cipher suite names follow the naming convention: CipherSuite TLS\_AEAD\_HASH = VALUE;}
  \label{tab:ciphersuites}
\end{table}




% \begin{align*}
%     & \textbf { ClientHello } \\
%     & u:=g^\alpha, \mathcal{N}_{\mathrm{c}}, offer \\
%     & \textbf { ServerHello } \\
%     & v:=g^\beta, \mathcal{N}_{\mathrm{s}}, \text { mode } \\ 
%     & c_1:=E_{\mathrm{s}}\left(k_{\mathrm{sh}}, \text { CertReqest }\right) \\ 
%     & c_2:=E_{\mathrm{s}}\left(k_{\mathrm{sh}}, \operatorname{Cert}_Q\right) \\ 
%     & c_3:=E_{\mathrm{s}}\left(k_{\mathrm{sh}}, \text { Sig }\right. \\ 
%     & \left.c_4\left(u, \mathcal{N}_{\mathrm{c}}, \text { offer }, v, \mathfrak{N}_{\mathrm{s}}, \text { mode }, c_1, c_2\right)\right) \\ 
%     & c_4=E_{\mathrm{s}}\left(k_{\mathrm{sh}}, S\left(k_{\mathrm{sm}},\left(u, \mathfrak{N}_{\mathrm{c}}, \text { offer }, v, \mathfrak{N}_{\mathrm{s}}, \text { mode }, c_1, c_2, c_3\right)\right)\right) \\
%     & \left(k_{\mathrm{sh}}, k_{\mathrm{sm}}, k_{\mathrm{ch}}, k_{\mathrm{cm}}\right):=H_1\left(g^{\alpha \beta}, u, \mathcal{N}_{\mathrm{c}}, \text { offer }, v, \mathcal{N}_{\mathrm{s}}, \text { mode }\right) \\
%     & \left(k_{\mathrm{c} \rightarrow \mathrm{s}}, k_{\mathrm{s} \rightarrow \mathrm{c}}\right):=H_2\left(g^{\alpha \beta}, u, \mathcal{N}_{\mathrm{c}}, \text { offer, } v, \mathfrak{N}_{\mathrm{s}}, \text { mode }, c_1, \ldots, c_4\right) \\
%     & \text { ClientKeyExchange } \\
% \end{align*}
