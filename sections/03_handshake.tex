For consistency with the notation, we let P play the role of the client and Q play the role of the server. P and Q wish to setup a secure session. 

\textbf{TLS 1.3} supports both one-sided and mutual authentication. In most cases, authentication for the client is optional. In the notation, $(E_s , D_s)$ is a symmetric encryption scheme that provides authenticated encryption, such as AES-128 in GCM mode.  Algorithm $S$ refers to a MAC signing algorithm, such as HMAC-SHA256. Algorithms $Sig_P(\cdot )$ and $Sig_Q(\cdot )$ sign the provided data using P's or Q's signing keys. Finally, the hash functions $H_1, H_2$ are used to derive symmetric keys. They are built from HKDF with hash functions such as SHA-256. 

The cipher-suites which determine the symmetric encryption scheme, the hash function in the MAC signing algorithm and HKDF are negotiated during the handshake. The cipher-suites are defined in \cite{rfc8446}. They are specified in Table \ref{tab:ciphersuites}. TLS negotiates these algorithms, rather than hard code a specific choice, because some organizations may prefer to use different algorithms based on their policies.


\textbf{The protocol.} In the first step \textbf{Client Hello}, P sends a message to Q. The message contains a 32 bytes nonce $\mathcal{N}_c$ generated by a secure random number generator and an ``offer''. The offer specifies the group, a list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. In fact, the client can provide several groups in his offer using a ``supported\_groups'' extension though constrained to be one of several pre-defined groups, which include both elliptic curves and subgroups of finite fields. A ``key\_share'' extension provides corresponding group elements for each group. Clients which desire the server to authenticate itself via a certificate must send the ``signature\_algorithms'' extension which indicates the signature algorithms the client can accept. 

After receiving the first flow, the server Q examines the ``offer'' sent by the client. It verifies that the group (or groups) preferred by the client coincides with the group (or groups) that the server is able and willing to use. It also selects an encryption scheme $(E_s , D_s)$ and a hash function
from the offer that it is willing and able to use, if any. If the server is unable to find a compatible group and encryption/hash schemes, the server may send a special ``retry'' request to the client.

The server now responds with \textbf{Server Hello} containing its own nonce $\mathcal{N}_s$, a ``mode'' message which
indicates the parameter choices (group, encryption/hash scheme) made by the server along with the key share corresponding to the selected group. At this point, the server has enough information to compute the client handshake traffic secret (CHTS) and server handshake traffic secret (SHTS) values, and uses these to derive client and server handshake traffic keys ($tk_{chs}$ and $tk_{shs}$, respectively) \\ The server now begins to encrypt all handshake messages under $tk_{shs}$, and any extensions that
are not required to establish the server handshake traffic key are sent (and encrypted) in the \textbf{EncryptedExtensions} (EE) messages \cite{10.1145/2810103.2813653}.

\begin{table}[t]
  \centering
  \begin{tabular}{|l|l|}
    \hline Description & Value \\
    \hline 
    TLS\_AES\_128\_GCM\_SHA256 & $\{0\times13,0\times01\}$ \\
    \hline TLS\_AES\_256\_GCM\_SHA384 & $\{0\times13,0\times02\}$ \\
    \hline TLS\_CHACHA20\_POLY1305\_SHA256 & $\{0\times13,0\times03\}$ \\
    \hline TLS\_AES\_128\_CCM\_SHA256 & $\{0\times13,0\times04\}$ \\
    \hline TLS\_AES\_128\_CCM\_8\_SHA256 & $\{0\times13,0\times05\}$ \\
    \hline
  \end{tabular}
  \caption{Cipher-Suites \cite{rfc8446}. Cipher suite names follow the naming convention: CipherSuite TLS\_AEAD\_HASH = VALUE;}
  \label{tab:ciphersuites}
\end{table}

SHTS/CHTS can be derived as follows \cite{rfc8446}:
% \begin{equation}
%   \label{eq:server_handshake_traffic_secret}
  \begin{verbatim}
  early sercret (ES) =  HKDF-Extract(0, 0)
  derived early secret (dES) = Derive-Secret(ES, "derived", "")
  handshake secret (HS) =  HKDF-Extract(dES, (EC)DHE shared secret)
  SHTS = Derive-Secret(HS, "s hs traffic", ClientHello...ServerHello)
  CHTS = Derive-Secret(HS, "c hs traffic", ClientHello...ServerHello)
  \end{verbatim}
% \end{equation}

The server sends \textbf{EncryptedExtensions} message immediately after the ServerHello message for sending extensions that can be protected. This is followed by \textbf{Certificate Request} message, which is only sent if the server wishes to authenticate the client. If present, this message specifies the type of certificates the server will accept. Finally, the server sends \textbf{Authentication Messages} for authentication, key confirmation (provide explicit proof that an endpoint possesses the private key corresponding to its certificate), and handshake
integrity: \textbf{Certificate}, \textbf{CertificateVerify}, and \textbf{Finished}. All handshake messages in this phase are encrypted under $tk_{shs}$ or $tk_{chs}$. n the full 1-RTT handshake (TODO: Explain 1-RTT and 0-RTT), authentication is based on public key certificates. In pre-shared key handshakes (both PSK and PSK-(EC)DHE), the
server and client will authenticate each other by relying on a message authentication code applied to the transcript. (TODO: This part needs clarity)
\begin{itemize}
  \item ServerCertificate(SV): The server's certificate, and any supporting certificates in the chain.
  
  \item ServerCertificateVerify(SCV): A signature over the value  Transcript-Hash \footnote{Transcript-Hash is computed by hashing the concatenation of each included handshake message, including the handshake message header carrying the handshake message type and length fields, but not including record layer headers \cite{rfc8446}.}(Handshake Context, Certificate). Here, Handshake Context consists of \code{ClientHello}, \code{ServerHello},\\ \code{EncryptedExtensions}, and \code{CertificateRequest} (the conversation so far) using server's signing key. 

 \item ServerFinished(SF): This is the final message in the Authentication Messages. It is essential for providing authentication of the handshake and of the computed keys. The server first derives a server finished key $fk_S$ from SHTS and then computes a MAC tag SF over \code{Transcript-Hash(Handshake Context,Certificate, CertificateVerify)}. This value is also encrypted under $tk_{shs}$, sending the output ciphertext to the client. At this point, the server is able to compute the client application traffic secret (CATS), the server application traffic secret (SATS), and the exporter master secret (EMS).  It can now compute the client application traffic key $tk_{capp}$ and the server application traffic key $tk_{sapp}$ and it can begin sending encrypted application data to the client.
 \begin{equation}
  fk_S = \code{HKDF-Expand-Label(SHTS, ``finished'', '', Hash.length)}
 \end{equation}

 We can derive the traffic keys as follows:
  \begin{equation}
    \label{eq:traffic_keys}
    \begin{split}
      \code{dHS} &= \code{Derive-Secret(HS, "derived", "")} \\
      \code{MS} &= \code{HKDF-Extract(dHS, 0)} \\
      \code{CATS} &= \code{Derive-Secret(MS, "c ap traffic", ClientHello...Server Finished)} \\
      \code{SATS} &= \code{Derive-Secret(MS, "s ap traffic", ClientHello...Server Finished)} \\
      tk_{capp} &= \code{HKDF-Expand-Label(CATS, "key", "", key\_length)} \\
      tk_{sapp} &= \code{HKDF-Expand-Label(SATS, "key", "", key\_length)} 
    \end{split}
  \end{equation}
  \end{itemize}

  \textbf{Client verification, authentication, key confirmation, and key derivation}. The client P,
  upon receiving these messages, checks that the signature SCV (if in full 1-RTT mode) and the  MAC SF verify correctly. If the server Q has requested client authentication, P will begin by sending its digital certificate (carrying its public-key) in the \code{ClientCertificate} message, after which P will compute its own certificate verify value \code{ClientCertificateVerify} by signing the session hash, then send it to Q as the \code{CertificateVerify} message. P finally derives the client finished key $fk_C$ from CHTS and uses $fk_C$ to compute a MAC tag CF over the session hash.

  \textbf{Server verification}. The server will verify the final MAC (CF) and optional signature (CCV) messages of the client.

  \textbf{Handshake completion.} At this point both parties can compute the resumption master secret (RMS) value that can be used as a pre-shared key for session resumption in the future. Both parties can now derive the client application traffic key ($tk_{capp}$), and use the record layer for encrypted communication of application data with the resulting keys.
  \begin{equation}
    RMS = \code{Derive-Secret(MS, "res master", ClientHello...Client Finished)}
  \end{equation}





% \begin{align*}
%     & \textbf { ClientHello } \\
%     & u:=g^\alpha, \mathcal{N}_{\mathrm{c}}, offer \\
%     & \textbf { ServerHello } \\
%     & v:=g^\beta, \mathcal{N}_{\mathrm{s}}, \text { mode } \\ 
%     & c_1:=E_{\mathrm{s}}\left(k_{\mathrm{sh}}, \text { CertReqest }\right) \\ 
%     & c_2:=E_{\mathrm{s}}\left(k_{\mathrm{sh}}, \operatorname{Cert}_Q\right) \\ 
%     & c_3:=E_{\mathrm{s}}\left(k_{\mathrm{sh}}, \text { Sig }\right. \\ 
%     & \left.c_4\left(u, \mathcal{N}_{\mathrm{c}}, \text { offer }, v, \mathfrak{N}_{\mathrm{s}}, \text { mode }, c_1, c_2\right)\right) \\ 
%     & c_4=E_{\mathrm{s}}\left(k_{\mathrm{sh}}, S\left(k_{\mathrm{sm}},\left(u, \mathfrak{N}_{\mathrm{c}}, \text { offer }, v, \mathfrak{N}_{\mathrm{s}}, \text { mode }, c_1, c_2, c_3\right)\right)\right) \\
%     & \left(k_{\mathrm{sh}}, k_{\mathrm{sm}}, k_{\mathrm{ch}}, k_{\mathrm{cm}}\right):=H_1\left(g^{\alpha \beta}, u, \mathcal{N}_{\mathrm{c}}, \text { offer }, v, \mathcal{N}_{\mathrm{s}}, \text { mode }\right) \\
%     & \left(k_{\mathrm{c} \rightarrow \mathrm{s}}, k_{\mathrm{s} \rightarrow \mathrm{c}}\right):=H_2\left(g^{\alpha \beta}, u, \mathcal{N}_{\mathrm{c}}, \text { offer, } v, \mathfrak{N}_{\mathrm{s}}, \text { mode }, c_1, \ldots, c_4\right) \\
%     & \text { ClientKeyExchange } \\
% \end{align*}
